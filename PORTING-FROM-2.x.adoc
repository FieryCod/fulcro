== Porting From Fulcro 2.x

Fulcro 3 is intended to be as API-friendly to Fulcro 2 applications as
possible but internal cleanup and changes mean that existing applications will
have to at least make some name changes, and in many cases clean
up arguments and logic. This document covers the known porting
tasks. If you run into an issue when porting that is not documented
here please ask on the Fulcro Slack channel in Clojurians.

as the new official teminology in its function and parameter naming.
Since we're renaming a bunch of stuff already: Fulcro 3 may adopt "lookup ref" or "ref"

One problem is that `ref` is another already claimed "thing", and `:lookup-ref` is
a bit cumbersome to type.

=== Namespaces and Name Changes

Since the API changed, we thought it a good opportunity to clean
up some naming and split things into smaller files. This will help
with long-term maintenance of the project.

If you look at the `com.fulcrologic.fulco` package you should be able
to guess the location of the function you need. There are some functions
that were moved out of Fulcro completely or were dropped because they
were deprecated or no longer made sense.

The following list documents some common ones that you might be using, 
and where to find them now:

`ident?`:: Most EQL-related functions like this are in the
    `edn-query-language.core` namespace.

`merge-*`:: Merge-related logic is now in the
`com.fulcrologic.fulcro.algorithms.merge` namespace.


=== API Improvements that Should Not Hurt

Default query transform:: When issuing loads the new code elides `:ui/...` keywords
*and also* the form-state config join.

Rendering:: The default renderer no longer needs "follow-on reads".  Performance
testing showed that the process of trying to figure out UI updates from the indexes
added more overhead than they saved.  The rendering optimizations are actually pluggable,
and two versions of the algorithm are supplied: one that always renders from root
(`keyframe-render`) and relies on `shouldComponentUpdate` for performance,
and one that uses database analysis to find the minimum number of components to update.
Different applications might find one better than the other depending on usage patterns.
Both should be faster than Fulcro 2 for various internal reasons.  Until heavy use proves otherwise
The "keyframe" one is more likely to be bug-free.  There is some chance that I'll support
follow-on reads as a fallback to the 2.x meaning (when they are present on a tx). In general the majority
of the overhead at this point is in React, so relying on Fulcro 3 to calculate what to refresh is not likely to
be your bottleneck.

Pessimistic Transactions:: These were always a bit of a "hard edge" in Fulcro 2.  In the JS world the ability to
"chain" operations in callbacks with async/await is just sometimes desirable. Fulcro 3 allows this sort of thing
more directly (though it still keeps it
out of the UI layer). The new mutation abilities allow you to chain your next operation from the network
result of a prior one right in the mutation's declaration.  `ptransact!` is technically still supported, and
actually should even have a bug or two fixed, but should probably not be used in new applications.

Transactions:: The new transact API uses a proper submission queue. This gets rid of internal uses of core async,
makes the internals more visible to APIs and tooling, and even allows for the entire transaction processing system
to be "pluggable".  The new system allows `transact!` to be safely called from anywhere. Semantically speaking it
should not be called from within `swap!`, though in js (single-threaded) even *that* would not hurt anything
with the new implementation.

`defmutation`:: The `defmutation` macro on the client side "looks" the same as the old one; however, it is quite a bit
more powerful.  Lessons learned in incubator and with pessimistic mutations led to a complete redesign.  Dumping the
internal structure of Om Next simplified the whole process greatly.  The backing `defmulti` is still there, but the arguments
changed (it takes only and env now), and you are guaranteed that the built-in tx processing will only ever call the
method *once*.  Remotes are now truly lambdas (instead of values), and receive an env that allows them to see app state
as it existed before the optimistic update.

=== Breaking API Changes

Full-Stack:: The happy path is mostly the same for full-stack operation; however, The overall network error handling is
completely different.  There is still a global error handler, but it gets
a more detailed environment (and a new name). *Mutation* fallbacks are no longer supported. See the new mutations, which
have `result-action` and `error-action` sections to handle per-mutation errors. Load fallbacks are still supported, as
they were already targeted to the load in question. Global network activity and error markers have changed. See the
developer's guide for more details.

React Lifecycle Methods:: The *non-static* React lifecycle methods (e.g. componentDidMount, shouldComponentUpdate, etc.) now all require
an explicit `this`. Everything in the options map in Fulcro 3 except query/ident/initial-state are completely literal
(e.g. lambdas or data).

Mutation Multimethod:: The `defmulti` for mutations is still present, but the API is presents and the return value
it expects have changed.  If you directly use `defmethod m/mutate` you will need to adapt your code.

Initial State:: The initial state story is the same if your initial state is purely on your root component. If
you were passing an initial state to the reconciler, then that option has changed.  You can pass a *normalized* database
to `fulcro-app`, and you can turn on/off auto inclusion of initial state from root via `mount!`.

App vs. Reconciler:: There is no longer a separate reconciler or indexer.  Everything
is in the app, and is held in atoms such that there is no need to do top-level swaps. Your
app can be declared once in a namespace of it's own and then used directly everywhere
the reconciler could have been. There are no protocols involved.

Returning and Targeting:: The `returning`, `with-target`, and `with-params` helpers take `env` now.  The return value
of client-side mutations now support returning the `env` in addition to the original boolean or AST. The `append-to` and
related targeting wrappers are now in the targeting namespace.

Remotes:: Remotes were protocol based, and are now simply maps. The primary
"method" to implement is a function under the `:transmit!` key, which now receives
a send node and should return a result that includes both the status code and EDN
result.  There are new versions of pre-supplied HTTP and Websocket remotes that
should be top-level API compatible with your existing code.

Server:: Easy server is gone. Supported server middleware helpers and config support
are in the `com.fulcrologic.fulcro.server` package. Fulcro 3 no longer supplies
server-side macros for mutations and reads, as `pathom` is a much better choice for
EQL service. Porting to Pathom is relatively minor, and if you want a "no source change" solution you can
simple write macros like this:

```
(def resolvers (atom []))

(s/def ::root-value (s/cat
                      :value-name (fn [sym] (= sym 'value))
                      :value-args (fn [a] (and (vector? a) (= 2 (count a))))
                      :value-body (s/+ (constantly true))))

(s/def ::query-root-args (s/cat
                           :kw keyword?
                           :doc (s/? string?)
                           :value #(and (list? %) (= 'value (first %)) (vector? (second %)))))

(defn defquery-root* [env args]
  (let [target-sym (::sym env)
        ;; conform! is just an exception-throwing version of s/conform
        {:keys [kw doc value]} (util/conform! ::query-root-args args)
        {:keys [value-args value-body]} (util/conform! ::root-value value)
        env-sym    (first value-args)
        params-sym (second value-args)]
    `(do
       (pc/defresolver ~target-sym [~'env__internal ~'_]
         ~(cond-> {::pc/output [kw]}
            doc (assoc :doc doc))
         (let [~env-sym ~'env__internal
               ~params-sym (-> ~'env__internal :ast :params)]
           {~kw (do ~@value-body)}))
       (swap! resolvers conj ~target-sym))))

(defmacro defquery-root [& args]
  (defquery-root* (assoc &env ::sym (gensym "query")) args))
```

UI State Machines:: The names of a few parameters on API for
doing loads and mutations were named. The load `::uism/post-event` was
renamed to `::uism/ok-event`, fallbacks to error, etc.  The targeting
namespace on the target for mutations was change to data-targeting, and
the namespace for returning was change to normal mutations ns. The return
value of mutations appears in ::uism/mutation-result now, and
is the Fulcro 3 raw network result (status code, body, etc.).

